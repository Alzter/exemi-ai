import requests, httpx
from copy import copy

from typing import Union, Annotated

import jwt
from jwt.exceptions import InvalidTokenError
from fastapi import FastAPI, Depends, HTTPException, status
from fastapi.security import OAuth2PasswordBearer, OAuth2PasswordRequestForm
from fastapi.middleware.cors import CORSMiddleware
from pydantic import BaseModel

from pwdlib import PasswordHash
password_hash = PasswordHash.recommended() # Argon2 password hash algorithm

from datetime import datetime

SECRET_KEY = "3be8f0c5dc7c22f135e283712251937d8f0aae7900310c9e47077ad4c4190737"
ALGORITHM = "HS256"
ACCESS_TOKEN_EXPIRE_MINUTES = 30

app = FastAPI()

origins = [
    "http://localhost:5173",
    "https://localhost:5173"
]

app.add_middleware(
    CORSMiddleware,
    allow_origins=origins,
    allow_credentials=True,
    allow_methods=["*"],
    allow_headers=["*"],
)

oauth2_scheme = OAuth2PasswordBearer(tokenUrl="token")

fake_users_db = {
    "1" : {
        "username":"1",
        "hashed_password":"$argon2id$v=19$m=65536,t=3,p=4$wagCPXjifgvUFBzq4hqe3w$CYaIb8sB+wtD+Vu/P4uod1+Qof8h+1g7bbDlBID48Rc",
        "disabled":False
        },
    "2": {
        "username":"2",
        "hashed_password":"fakehasheddef",
        "disabled":True
        }
}

class Token(BaseModel):
    access_token : str
    token_type : str

class TokenData(BaseModel):
    username : str | None = None

class User(BaseModel):
    username: str 
    canvas_token : str | None = None
    disabled : bool | None = None

# Identical class to User, only hashed_password is mandatory.
class UserInDB(User):
    hashed_password: str

class Message(BaseModel):
    role : str
    content : str
    timestamp : datetime

class Conversation(BaseModel):
    messages : list[Message]
    user : User
    timestamp : datetime

def verify_password(plain_password, hashed_password):
    return password_hash.verify(plain_password, hashed_password)

def get_password_hash(password):
    return password_hash.hash(password)

def get_user(db, username : str):
    if username in db:
        user_dict = db[username]
        # Create a UserInDB class using fields from user_dict.
        # This will bork if required fields are missing!!!
        return UserInDB(**user_dict)

def authenticate_user(fake_db, username:str, password:str):
    user = get_user(fake_db, username)
    if not user: return False
    if not verify_password(password, user.hashed_password): return False
    return user

def fake_hash_password(password : str):
    # TODO: This is insecure
    return "fakehashed" + password

def fake_decode_token(token : Annotated[str, Depends(oauth2_scheme)]):
    # TODO: This is insecure (why?)
    user = get_user(fake_users_db, token)
    return user

async def get_current_user(token : Annotated[str, Depends(oauth2_scheme)]):
    user = fake_decode_token(token)
    if not user:
        raise HTTPException(
            status_code=status.HTTP_401_UNAUTHORIZED,
            detail="Not authenticated",
            headers={"WWW-Authenticate":"Bearer"}
        )
    return user

async def get_current_active_user(current_user : Annotated[User, Depends(get_current_user)]):
    if current_user.disabled:
        raise HTTPException(status_code=400, detail="Inactive user")
    return current_user

@app.get("/users/me")
async def read_users_me(current_user : Annotated[User, Depends(get_current_active_user)]):
    return current_user

@app.get("/items/")
async def read_items(token: Annotated[str, Depends(oauth2_scheme)]):
    return {"token": token}

@app.get("/")
def read_root():
    return {"Hello": "World"}

@app.post("/is_token_valid/")
async def is_token_valid(provider : str, access_token : str) -> bool:
    """
    Verify whether a manual Canvas API token generated by a user is valid for a given Canvas installation.

    Args:
        provider (str): The name of the institution which has installed Canvas.
        access_token (str): A manually generated Canvas access token.

    Returns:
        exists (bool): Returns true if the user's access token is valid for the given Canvas provider.
    """
    async with httpx.AsyncClient(timeout=5) as client:
        response = await client.get(f"https://{provider}.instructure.com/api/v1/users/self", params={
        "access_token":access_token,
        })
    return response.status_code == 200

@app.post("/token")
async def login(form_data : Annotated[OAuth2PasswordRequestForm, Depends()]):

    # Determine if user exists
    user_dict = fake_users_db.get(form_data.username)
    if not user_dict:
        raise HTTPException(status_code=400, detail="Incorrect username or password")
    
    # If user does exist, obtain their password hash
    user = UserInDB(**user_dict)
    hashed_password = fake_hash_password(form_data.password)
    
    # Hash the password provided and compare it to the real password hash
    if not hashed_password == user.hashed_password:
        raise HTTPException(status_code=400, detail="Incorrect username or password")
     
    # TODO: This is insecure, the access token shall not be the user's ID.
    return {"access_token": user.username, "token_type":"bearer"}

@app.post("/chat_start/")
async def chat_start(user : Annotated[User, Depends(get_current_active_user)]):
    """
    Create a new conversation between a user and the assistant.
    """
    return Conversation(
        messages = [],
        user=user,
        timestamp=datetime.now()
    )

def chat_add(conversation : Conversation, new_message : Message) -> Conversation:
    """
    Append a new message to an existing Conversation.
    """
    return conversation.model_copy(
        update={
            "messages": [*conversation.messages, new_message]
        }
    ) 

@app.post("/chat/")
async def chat(conversation : Conversation, query : str):
    """
    For a given conversation, add a user query and then generate an LLM response.
    """

    user_message = Message(role="user",content=query,timestamp=datetime.now())

    new_conversation = chat_add(conversation, user_message)

    assistant_message = Message(role="assistant",content="Hello! This is a placeholder!", timestamp=datetime.now())

    new_conversation = chat_add(new_conversation, assistant_message)

    return new_conversation

# @app.post("/login/")
# async def login(credentials:dict):
# 
#     provider = credentials["provider"]
#     access_token = credentials["token"]
# 
#     legit = await is_token_valid(provider, access_token)
# 
#     print(legit)
# 
#     if not legit:
#         return HTTPException(status_code = 401, detail=f"Canvas access token for {provider} installation is invalid.")
#     
#     return "Authorised"
