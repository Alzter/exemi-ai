import os
import jwt
from jwt.exceptions import ExpiredSignatureError
import httpx
from datetime import datetime, timezone, timedelta
from sqlmodel import Session, create_engine, select
from dotenv import load_dotenv
from datetime import timedelta
from fastapi import Depends, HTTPException
from fastapi.security import OAuth2PasswordBearer
from .models import User

load_dotenv()

# Establish a connection to the database.
# TODO: Make the connection URL specified elsewhere! 
url = "mariadb+mariadbconnector://root:root@127.0.0.1:3306/exemi"
engine = create_engine(url, echo=True)

oauth2_scheme = OAuth2PasswordBearer(tokenUrl="login")

def get_engine(): return engine

def get_session():
    with Session(engine) as session:
        yield session

def get_secret_key() -> str:
    key = os.environ["SECRET_KEY"]
    if key is None: raise Exception("HS256 encryption/decryption key not found!")
    return key

def get_oauth2_scheme(): return oauth2_scheme

async def get_current_user(token : str = Depends(oauth2_scheme), session : Session = Depends(get_session)) -> User:
    fail = HTTPException(
        status_code=401,
        detail="Please log in first",
        headers={"WWW-Authenticate":"Bearer"}
    )
    try:
        json_web_token_data = jwt.decode(token, get_secret_key(), algorithms=["HS256"])
    except ExpiredSignatureError:
        raise HTTPException(
            status_code=401,
            detail="Login session has timed out. Please log in again",
            headers={"WWW-Authenticate":"Bearer"}
        )

    username = json_web_token_data.get("sub")
    if username is None: raise fail
    user = session.exec(
        select(User).where(User.username == username)
    ).first()
    if not user: raise fail 
    return user

async def is_magic_valid(provider : str, magic : str) -> bool:
    """
    Verify whether a manual magic generated by a user is valid for a given magic installation.

    Args:
        provider (str): The name of the institution which has installed magic.
        access_token (str): A manually generated magic.

    Returns:
        exists (bool): Returns true if the user's magic is valid for the given magic provider.
    """
    async with httpx.AsyncClient(timeout=15) as client:
        response = await client.get(f"https://{provider}.instructure.com/api/v1/users/self", params={
        "access_token":magic,
        })
    return response.status_code == 200

async def encrypt_magic(magic : str, university_name : str | None, expiry : timedelta | None = timedelta(weeks=4)) -> str:
    if university_name is None: raise HTTPException(status_code=400, detail="university_name must be given when providing a magic")

    legit = await is_magic_valid(university_name, magic)

    if not legit:
        raise HTTPException(
            status_code=401,
            detail="Canvas API token is invalid",
            headers={"WWW-Authenticate":"Bearer"}
        )

    data = {"sub":magic}
    if expiry is not None: data["exp"] = datetime.now(timezone.utc) + expiry
    return jwt.encode(data, key=get_secret_key(), algorithm="HS256")

def decrypt_magic_hash(magic_hash : str) -> str:
    fail = HTTPException(
        status_code = 401,
        detail = "Error retrieving Canvas API token. Please create a new API token",
        headers = {"WWW-Authenticate":"Bearer"}
        )
    try:
        magic_data = jwt.decode(magic_hash, key=get_secret_key(), algorithms=["HS256"])
        magic = magic_data.get("sub")
        if not magic: raise fail
    except: raise fail
    return magic

async def get_current_magic(user : User = Depends(get_current_user)) -> str:
    """
    Given a user is logged in, obtain their magic and university_name in plaintext.

    Args:
        user (User): The current logged in user.
    
    Raises:
        HTTPException: If the user does not have a magic or university_name set, raises a 404 Exception.

    Returns:
        magic (str): The user's magic in plaintext.
    """
    magic_hash, university_name = user.magic_hash, user.university_name
    if magic_hash is None: raise HTTPException(status_code=404,detail="User does not have a Canvas API token")
    if university_name is None: raise HTTPException(status_code=404, detail="User does not have a university assigned, which is required to obtain their Canvas API token")
    magic = decrypt_magic_hash(magic_hash)
    return magic

